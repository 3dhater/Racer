/*
 * QDMVideoIn - definition/implementation
 * NOTES:
 * - Generated by mkclass
 * (C) 01-01-98 MarketGraph/RVG
 */

#include <qlib/dmvideoin.h>
#include <qlib/app.h>
#include <qlib/debug.h>
DEBUG_ENABLE

QDMVideoIn::QDMVideoIn(int source,int _class)
  : QDMObject()
{
  QVideoServer *vs;
  int x,y;

  //DEBUG_C(qdbg("QDMVideoIn ctor\n"));
  vs=app->GetVideoServer();
  // Nodes from video to memory
  srcVid=new QVideoNode(vs,VL_SRC,_class,source);
  drnMem=new QVideoNode(vs,VL_DRN,VL_MEM,VL_ANY);
  // Create path
  pathIn=new QVideoPath(vs,VL_ANY,srcVid,drnMem);

  if(_class==VL_SCREEN)
  { srcVid->SetControl(VL_FLICKER_FILTER,TRUE);
    srcVid->SetControl(VL_MVP_FULLSCREEN,FALSE);
  }
  // Setup hardware
  if(!pathIn->Setup(VL_SHARE,VL_SHARE))
  { qerr("QDMVideoIn: can't setup input path");
  }

  // Default control values
  SetTiming(VL_TIMING_625_CCIR601);
  SetPacking(VL_PACKING_YVYU_422_8);
  //SetPacking(VL_PACKING_RGB_8);
  drnMem->SetControl(VL_CAP_TYPE,VL_CAPTURE_NONINTERLEAVED);
  //drnMem->SetControl(VL_CAP_TYPE,VL_CAPTURE_INTERLEAVED);
  drnMem->SetControl(VL_FORMAT,VL_FORMAT_RGB);
  //drnMem->SetControl(VL_RATE,25,1);

  srcVid->GetXYControl(VL_SIZE,&x,&y);
#ifdef OBS
  if(_class!=VL_SCREEN)
    SetZoomSize(x,y);
#endif

  //drnMem->SetControl(VL_ORIGIN,0,16);		// ??
  drnMem->SetControl(VL_ZOOM,1,1);
  //srcVid->SetControl(VL_TIMING,VL_TIMING_625_CCIR601);
  //drnMem->SetControl(VL_CAP_TYPE,VL_CAPTURE_INTERLEAVED);
  SetLayout(VL_LAYOUT_GRAPHICS);
  //SetLayout(VL_LAYOUT_LINEAR);

  // Default events to listen to
  events=VLTransferCompleteMask |
         VLStreamBusyMask |
         VLStreamPreemptedMask |
         VLAdvanceMissedMask |
         VLStreamAvailableMask |
         VLSyncLostMask |
         VLStreamStartedMask |
         VLStreamStoppedMask |
         VLSequenceLostMask |
         VLControlChangedMask |
         VLTransferCompleteMask |
         VLTransferFailedMask |
         //VLEvenVerticalRetraceMask |
         //VLOddVerticalRetraceMask |
         //VLFrameVerticalRetraceMask |
         VLDeviceEventMask |
         VLDefaultSourceMask |
         VLControlRangeChangedMask |
         VLControlPreemptedMask |
         VLControlAvailableMask |
         VLDefaultDrainMask |
         VLStreamChangedMask |
         VLTransferError;

  // Debug
  //qdbg("  video in transfer size=%d\n",pathIn->GetTransferSize());
  drnMem->GetXYControl(VL_SIZE,&x,&y);
  //qdbg("  video in size: %dx%d\n",x,y);
}

QDMVideoIn::~QDMVideoIn()
{
  delete pathIn;
  delete drnMem;
  delete srcVid;
}

/*******
* POOL *
*******/
void QDMVideoIn::AddProducerParams(QDMBPool *pool)
// Get necessary params to use this input object
{
#ifdef USE_VL_65
  vlDMGetParams(app->GetVideoServer()->GetSGIServer(),
    pathIn->GetSGIPath(),drnMem->GetSGINode(),
    pool->GetCreateParams()->GetDMparams());
#else
  // VL O2
  vlDMPoolGetParams(app->GetVideoServer()->GetSGIServer(),
    pathIn->GetSGIPath(),drnMem->GetSGINode(),
    pool->GetCreateParams()->GetDMparams());
#endif
  /*qdbg("QDMVideoIn:GetPoolParams; buffersize=%d\n",
    pool->GetCreateParams()->GetInt(DM_BUFFER_SIZE));*/
}
void QDMVideoIn::RegisterPool(QDMBPool *pool)
{
  if(vlDMPoolRegister(app->GetVideoServer()->GetSGIServer(),
    pathIn->GetSGIPath(),drnMem->GetSGINode(),pool->GetDMbufferpool())<0)
    qerr("QDMVideoIn: can't register pool");
}

/*******
* INFO *
*******/
int QDMVideoIn::GetFD()
{
#ifdef USE_VL_65
  return drnMem->GetFD();
#else
  return pathIn->GetFD();
#endif
}
void QDMVideoIn::GetSize(int *w,int *h)
{
  drnMem->GetXYControl(VL_SIZE,w,h);
}
int QDMVideoIn::GetTransferSize()
{
  if(!pathIn)return 0;
  return pathIn->GetTransferSize();
}

void QDMVideoIn::SetSize(int w,int h)
{
  drnMem->SetControl(VL_SIZE,w,h);
}
void QDMVideoIn::SetZoomSize(int w,int h)
{
  drnMem->SetControl(VL_MVP_ZOOMSIZE,w,h);
}
void QDMVideoIn::SetOffset(int x,int y)
{
  drnMem->SetControl(VL_OFFSET,x,y);
}
void QDMVideoIn::SetOrigin(int x,int y)
{
//qdbg("QDMVideoIn::SetOrigin(%d,%d)\n",x,y);
  srcVid->SetControl(VL_ORIGIN,x,y);
}

void QDMVideoIn::SetLayout(int n)
{ drnMem->SetControl(VL_LAYOUT,n);
}
void QDMVideoIn::SetPacking(int n)
{ drnMem->SetControl(VL_PACKING,n);
}
void QDMVideoIn::SetCaptureType(int n)
{ drnMem->SetControl(VL_CAP_TYPE,n);
}
void QDMVideoIn::SetTiming(int n)
{ //drnMem->SetControl(VL_TIMING,n);
  srcVid->SetControl(VL_TIMING,n);
}

void QDMVideoIn::Start()
// Start transferring
{
#ifdef FUTURE
  VLTransferDescriptor xferDesc;
#endif
  pathIn->SelectEvents(events);

#ifdef FUTURE
  xferDesc.mode=VL_TRANSFER_MODE_CONTINUOUS;
  xferDesc.count=1;
  xferDesc.delay=0;
  xferDesc.trigger=VLTriggerImmediate;
#endif
  pathIn->BeginTransfer();
}
void QDMVideoIn::Stop()
{
  pathIn->EndTransfer();
}

/*********
* EVENTS *
*********/
void QDMVideoIn::AddEvents(int mask)
{
  events|=mask;
  if(pathIn)
  { // Live edit
    pathIn->SelectEvents(events);
  }
}

void QDMVideoIn::RemoveEvents(int mask)
{
  events&=~mask;
  if(pathIn)
  { // Live edit
    pathIn->SelectEvents(events);
  }
}

bool QDMVideoIn::GetEvent(VLEvent *event)
// This is actually not advised to use under USE_VL_65
// Use QVideoServer's event handling functions; this function
// will return events for ANY video path, not just the video out path (!)
//
// Returns TRUE if an event was fetched (none pending?), FALSE otherwise.
// BUGS: the new interface fetches global VL events; they used to be
// connected to a VLPath. So now we *should* use 1 global event fetcher
// and deliver those to the video thread (if there are multiple).
{
#ifdef USE_VL_65
  if(vlPending(app->GetVideoServer()->GetSGIServer())<=0)
    return FALSE;
  if(vlNextEvent(app->GetVideoServer()->GetSGIServer(),event)!=DM_SUCCESS)
#else
  if(vlEventRecv(app->GetVideoServer()->GetSGIServer(),
    pathIn->GetSGIPath(),event)!=DM_SUCCESS)
#endif
  { //qerr("QDMVideoIn:GetEvent failed vlEventRecv");
    return FALSE;
  }
  return TRUE;
}
